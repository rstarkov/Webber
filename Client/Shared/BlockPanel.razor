@using Microsoft.AspNetCore.SignalR.Client
@using Webber.Client.Models

@typeparam TDto where TDto : BaseDto
@implements IAsyncDisposable

<div class="BlockPanelContainer @cssClassValidity">
    @if (_lastUpdateReceivedUtc > DateTime.UtcNow.AddSeconds(-1.5))
    {
        <div class="JustUpdated"></div>
    }

    @if (!IsConnected)
    {
        <div class="Disconnected"></div>
    }

    @ChildContent(this)
</div>

@code {
    [Parameter]
    public RenderFragment<BlockPanel<TDto>> ChildContent { get; set; }

    private string cssClassValidity => LastUpdate == null || DateTime.UtcNow < LastUpdate.ValidUntilUtc ? "" : "Invalid"; // it's only null until first update; don't start the block with red stripes - typically blocks render blank content anyway

    private HubConnection _hubConnection;
    private CancellationTokenSource _cts = new();
    [Inject]
    private NavigationManager _navigationManager { get; set; }
    private DateTime _lastUpdateReceivedUtc;
    private System.Timers.Timer _invalidTimer = new System.Timers.Timer { AutoReset = false, Enabled = false };
    private System.Timers.Timer _justReceivedTimer = new System.Timers.Timer { AutoReset = false, Enabled = false, Interval = 2000 };

    public bool IsConnected => _hubConnection?.State == HubConnectionState.Connected;
    public TDto LastUpdate { get; private set; }

    protected override async Task OnInitializedAsync()
    {
        _invalidTimer.Elapsed += OnInvalidTimer;
        _justReceivedTimer.Elapsed += delegate { StateHasChanged(); };
        _hubConnection = new HubConnectionBuilder()
            .WithUrl(_navigationManager!.ToAbsoluteUri($"/hub/{typeof(TDto).Name.Replace("Dto", "")}"))
            .Build();
        _hubConnection.Closed += OnConnectionLost;
        _hubConnection.On<TDto>("Update", OnUpdateReceived);
        await ConnectWithRetryAsync();
        await base.OnInitializedAsync();
    }

    private void OnUpdateReceived(TDto dto)
    {
        LastUpdate = dto;
        _lastUpdateReceivedUtc = DateTime.UtcNow;
        _invalidTimer.Interval = Math.Max(1, (dto.ValidUntilUtc - DateTime.UtcNow).TotalMilliseconds);
        _invalidTimer.Enabled = true;
        _justReceivedTimer.Enabled = true;
        StateHasChanged();
    }

    private void OnInvalidTimer(object sender, System.Timers.ElapsedEventArgs e)
    {
        if (DateTime.UtcNow > LastUpdate!.ValidUntilUtc)
        {
            _invalidTimer.Enabled = false;
            StateHasChanged();
        }
        else
        {
            // It has fired before the validity interval has expired, in which case postpone it instead of disabling
            _invalidTimer.Interval = Math.Max(1, (LastUpdate.ValidUntilUtc - DateTime.UtcNow).TotalMilliseconds) + 100;
            _invalidTimer.Enabled = true;
        }
    }

    private async Task OnConnectionLost(Exception e)
    {
        StateHasChanged();
        await ConnectWithRetryAsync();
        StateHasChanged();
    }

    private async Task ConnectWithRetryAsync()
    {
        while (!_cts.Token.IsCancellationRequested)
        {
            try
            {
                await _hubConnection!.StartAsync(_cts.Token);
                return;
            }
            catch { }
            await Task.Delay(5000);
        }
    }

    public async ValueTask DisposeAsync()
    {
        GC.SuppressFinalize(this);
        _cts.Cancel();
        _cts.Dispose();
        _invalidTimer.Dispose();
        await _hubConnection!.DisposeAsync();
    }
}
